# JavaScript 核心知识点

## JS 更进一步：执行上下文与调用栈

### 为什么要有执行上下文

  分治思想
  我们可以把执行上下文理解为引擎在执行过程中对代码进行了又一次的 “划分”，这样做的目的，仍然是为了分解复杂度。



### 执行上下文是什么

  执行上下文，从定义上理解，是 “执行代码的环境”—— 这是一个专业且抽象的定义。

1. 执行上下文的分类

  全局上下文 —— 全局代码所处的环境，不在函数中的代码都在全局执行上下文中
  函数上下文 —— 在函数调用时创建的上下文
  Eval 执行上下文 —— 运行 Eval 函数中的代码时所创建的环境，Eval 被前端诟病多年，时下对 Eval 感兴趣的人非常少了，面试官也普遍对它嗤之以鼻。

2. 全局上下文的创建和组成

- 每一个执行上下文都会经历这样一个生命周期：
  创建阶段 —— 执行上下文的初始化状态，此时一行代码都还没有执行，只是做了一些准备工作
  执行阶段 —— 逐行执行脚本里的代码

  创建阶段： 
    创建全局对象（Window 有了）
    创建 this ，并让它指向全局对象
    给变量和函数安排内存空间
    默认给变量赋值为 undefined；将函数声明放入内存
    创建作用域链

    执行上下文在执行阶段里其实始终是处在一个动态过程  是按代码顺序走的

  - "变量提升"的本质：变量的创建过程（在上下文创建阶段完成）和真实赋值过程（在上下文执行阶段完成）的不同步带来的一种错觉。

### 函数上下文的创建和组成

  两者之间的不同主要体现在以下方面上：
    创建的时机 —— 全局上下文在进入脚本之初就被创建，而函数上下文则是在函数调用时被创建
    创建的频率 —— 全局上下文仅在代码刚开始被解释的时候创建一次；而函数上下文由脚本里函数调用的多少决定，理论上可以创建无数次
    创建阶段的工作内容不完全相同 —— 函数上下文不会创建全局对象（Window），而是创建参数对象（arguments）；创建出的 this 不再死死指向全局对象，而是取决于该函数是如何被调用的 —— 如果它被一个引用对象调用，那么 this 就指向这个对象；否则，this 的值会被设置为全局对象或者 undefined（在严格模式下）


### 调用栈
  
  当一个函数执行完毕，其对应的上下文必须让出之前所占用的资源。因此上下文的建立和销毁，就对应了一个” 入栈 “和” 出栈 “的操作。当我们调用一个函数的时候，就会把它的上下文推入调用栈里，执行完毕后出栈，随后再为新的函数进行入栈操作。


### 站在调用栈的角度，理解作用域的本质

  作用域其实就是当前所处的执行上下文。我们基于执行上下文，来理解一下作用域的特征：  作用域对外隔离

  1. 闭包 —— 特殊的 “弹出”
    在执行上下文的创建阶段，跟着被创建的还有作用域链！这个作用域链在函数中以内部属性的形式存在，在函数定义时，其对应的父变量对象就会被记录到这个内部属性里。闭包正是通过这一层作用域链的关系，实现了对父作用域执行上下文信息的保留。

  2. 自由变量的查找 —— 作用域链与上下文变量的结合
    函数内部找不到变量时，引擎会沿着作用域链向上找、定位到它对应的父级作用域的上下文、看有没有目标变量，如果还没有，那么就沿着作用域链继续往上定位、直到找到为止。
    这里是沿着作用域链找，可不是沿着调用栈一层一层往上找哦！调用栈是在执行的过程中形成的，而作用域链可是在书写阶段就决定了。
    例子： 
    ```js
    var name = 'xiuyan'
    function testA() {
      console.log('执行第一个测试函数的逻辑');
      testB();
      console.log('再次执行第一个测试函数的逻辑');
    }

    function testB() {
      console.log(name);
    }

    testA();
    ```

    每次调用函数时都会创建一个全新的函数执行环境对象，这个就是调用栈上的对象。初始化执行环境时会创建一个变量对象，然后初始化这个变量对象，最后确定 this 指向。每个函数调用都有一个自己的 this。变量对象/函数活动对象也是在函数调用时动态创建的，它不在调用栈上（不考虑解释器优化），它是单独分配创建的，函数里的局部变量以及参数都保存在这个变量对象中。执行环境包含一个作用域链属性，在创建执行环境时时，它把函数对象自身的作用域链属性复制过来，然后将本次调用的变量对象添加到作用域链顶端，这就形成了本次调用的作用域链。函数中的名字查找都是沿着这条作用域链进行的。注意，函数对象的作用域链是在函数对象创建时创建的，和执行环境的作用域链不是一回事。函数对象创建时，直接将外层执行环境对象的作用域链复制为自己的作用域链。这也说明了，js 函数是静态词法作用域。虽然外层函数执行完毕了，执行环境对象也出栈了，但是变量对象仍然被内嵌函数对象的作用域链所引用，它不会被回收。

    调用栈是在执行的过程中形成的，而作用域链可是在书写阶段就决定了。因此，testB 里找不到的变量，绝不会去 testA 里找，而是去全局上下文变量里找！
    