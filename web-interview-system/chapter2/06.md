# JavaScript 核心知识点

## JS 内存管理机制解析

### 内存生命周期

  JS 的内存生命周期，和大多数程序语言一样，分为三个阶段:
  “挖坑”—— 在内存空间这片广袤无垠的沃土里，划出自己的一亩三分地，此举称为 “分配内存”。不同的数据类型需要不同类型的内存空间。
  “用坑”—— 往你的一亩三分地里 “种菜” ：塞入你需要存储的信息。此后你可以读取它，也可以更改它，此举称为 “内存的读与写” 操作。
  “还坑”—— 用坑一时爽，但作为好公民，咱用完这个地就得及时上交给村里。这个 “还回去” 的动作，就叫做内存的释放。


### 栈内存与堆内存

1. 基本类型与引用类型

  其中基本类型包括：Sting、Number、Boolean、null、undefined、Symbol。这类型的数据最明显的特征是大小固定、体积轻量、相对简单，它们被放在 JS 的栈内存里存储。
  而排除掉基本类型，剩下的数据类型就是引用类型，比如 Object、Array、Function 等等等等。这类数据比较复杂、占用空间较大、且大小不定，它们被放在 JS 的堆内存里存储。

  堆和栈分别是不同的数据结构。栈是线性表的一种，而堆则是树形结构。
  基本类型变量的访问：从栈中直接获取该变量的值。
  引用变量的访问：1. 从栈中获取变量对应对象的引用（即它在堆内存中的地址）
                 2. 拿着 1 中获取到的地址，再去堆内存空间查询，才能拿到我们想要的数据

### 垃圾回收机制

  每隔一段时间，JS 的垃圾收集器就会对变量做 “巡检”。当它判断一个变量不再被需要之后，它就会把这个变量所占用的内存空间给释放掉，这个过程叫做垃圾回收。
  垃圾回收算法有两种 —— 引用计数法和标记清除法。

  1. 引用计数法 (已经被淘汰了)

   在引用计数法的机制下，内存中的每一个值都会对应一个引用计数。当垃圾收集器感知到某个值的引用计数为 0 时，就判断它 “没用” 了，随即这块内存就会被释放。

   缺点: 无法识别循环引用的场景   

  2. 标记清除法

  在标记清除算法中，一个变量是否被需要的判断标准，是它是否可抵达 。
  这个算法有两个阶段，分别是标记阶段和清除阶段：

  标记阶段：垃圾收集器会先找到根对象，在浏览器里，根对象是 Window；在 Node 里，根对象是 Global。从根对象出发，垃圾收集器会扫描所有可以通过根对象触及的变量，这些对象会被标记为 “可抵达”。
  清除阶段： 没有被标记为 “可抵达” 的变量，就会被认为是不需要的变量，这波变量会被清除

### 闭包与内存泄漏

  1. 啥是内存泄漏？
  该释放的变量（内存垃圾）没有被释放，仍然霸占着原有的内存不松手，导致内存占用不断攀高，带来性能恶化、系统崩溃等一系列问题，这种现象就叫内存泄漏。
```js
  var theThing = null;
  var replaceThing = function () {
    var originalThing = theThing;
    var unused = function () {
      if (originalThing) // 'originalThing'的引用
        console.log("嘿嘿嘿");
    };
    theThing = {
      longStr: new Array(1000000).join('*'),
      someMethod: function () {
        console.log("哈哈哈");
      }
    };
  };
  setInterval(replaceThing, 1000);
```
  要想揪出其中的问题，大家需要对 V8 引擎有所了解，尤其是这一点：在 V8 中，一旦不同的作用域位于同一个父级作用域下，那么它们会共享这个父级作用域。
  在这段代码里， unused 是一个不会被使用的闭包，但和它共享同一个父级作用域的 someMethod，则是一个 “可抵达”（也就意味着可以被使用）的闭包。unused 引用了 originalThing，这导致和它共享作用域的 someMethod 也间接地引用了 originalThing。结果就是 someMethod “被迫” 产生了对 originalThing 的持续引用，originalThing 虽然没有任何意义和作用，却永远不会被回收。不仅如此，originalThing 每次 setInterval 都会改变一次指向（指向最近一次的 theThing 赋值结果），这导致无法被回收的无用 originalThing 越堆积越多，最终导致严重的内存泄漏。

  2. 内存泄漏成因分析
  - “手滑” 导致的全局变量
  - 忘记清除的 setInterval 和 setTimeout
  - 清除不当的 DOM
