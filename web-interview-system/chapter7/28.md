# 事件循环专题


## Node中的Event-Loop与浏览器有何不同？


### Node技术架构分析-认识 libuv
Node整体上由这三部分组成：
- 应用层：这一层就是大家最熟悉的 Node.js 代码，包括 Node 应用以及一些标准库。
- 桥接层：Node 底层是用 C++ 来实现的。桥接层负责封装底层依赖的 C++ 模块的能力，将其简化为 API 向应用层提供服务。
- 底层依赖：这里就是最最底层的 C++ 库了，支撑 Node 运行的最基本能力在此汇聚。其中需要特别引起大家注意的就是 V8 和 libuv：
V8 是 JS 的运行引擎，它负责把 JavaScript 代码转换成 C++，然后去跑这层 C++ 代码。
libuv：它对跨平台的异步I/O能力进行封装，同时也是我们本节的主角：Node 中的事件循环就是由 libuv 来初始化的。
浏览器的 Event-Loop 由各个浏览器自己实现；而 Node 的 Event-Loop 由 libuv 来实现。

### Node 中的事件循环流程
1.  执行全局的 Script 代码（与浏览器无差）；
2. 把微任务队列清空：注意，Node 清空微任务队列的手法比较特别。在浏览器中，我们只有一个微任务队列需要接受处理；但在 Node 中，有两类微任务队列：next-tick 队列和其它队列。其中这个 next-tick 队列，专门用来收敛 process.nextTick 派发的异步任务。在清空队列时，优先清空 next-tick 队列中的任务，随后才会清空其它微任务；
3. 开始执行 macro-task（宏任务）。注意，Node 执行宏任务的方式与浏览器不同：在浏览器中，我们每次出队并执行一个宏任务；而在 Node 中，我们每次会尝试清空当前阶段对应宏任务队列里的所有任务（除非达到了系统限制）；
4. 步骤3开始，会进入 3 -> 2 -> 3 -> 2…的循环（整体过程如下所示）


### 浏览器的事件循环与Node的事件循环区别：
1. 浏览器的事件循环中只有一种微任务队列，Node中有两种，多了next-tick队列，并且此微任务队列最先执行
2. 浏览器的事件循环中宏任务出一个执行一个，Node的事件循环会将当前宏任务队列中所有的宏任务执行完

注：node11以后两者的事件循环一致，以浏览器的事件机制为主